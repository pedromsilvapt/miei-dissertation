$_default_layout = "qwertyuiop+´
asdfghjklçº~
<zxcvbnm,.-";

fun keyboard\debug ( $cb = none ) {
    return @keyboard {
        [ keyboard\KeyEvent() ] ( $key, $value, $pressed ): {
            if ($cb != none) {
                $cb( $key, $value, $pressed );
            } else {
                if ($pressed) { print( $key, $value, "PRESSED" ) } else { print( $key, $value, "RELEASED" ) };
            };
        };
    }
};

fun keyboard\piano ( $layout = $_default_layout, $hshift = @{}, $scales = @{}, $row_octaves = @{}, $transpose = 0; $toggle = false ) {
    fun get_row_scale ( $row_index ) {
        if ( $scales::has( $row_index ) ) {
            return $scales::get( $row_index );
        };

        if ( mod( $row_index, 2 ) == 0 ) {
            return $scale::white_keys;
        } else {
            return $scale::black_keys;
        };
    };

    $kb = keyboard\create();

    $rows = $layout::splitlines();

    $rows::reverse();

    $row_index = $rows::__len__() - 1;

    while ( $row_index >= 0 ) {
        $row_scale = get_row_scale( $row_index );

        $row_transpose = $hshift::get( $row_index, default = 0 );

        $row_base_octave = $row_octaves::get( $row_index, default = div( $row_index, 2 ) );

        $i = $row_transpose;

        for ( $letter in $rows::[ $row_index ] ) {
            $music = C + interval( octaves = $row_base_octave ) + $row_scale::interval_at( $i ) + $transpose;

            keyboard\register( $kb, key = $letter, expression = $music, hold = not $toggle, toggle = $toggle, extend = true );

            $i = $i + 1;
        };

        $row_index = $row_index - 1;
    };

    return $kb;
};

fun keyboard\midi ( $toggle = false, $transpose = 0 ) {
    $kb = keyboard\create();

    $bottom = C,,,,::first_note();
    $top = g'''''::first_note();

    while ( $bottom <= $top ) {
        # Important to declare the music to a variable because since we are inside a loop
        # If we didn't bound to a variable, it would always be bound to the last note of the loop
        $music = $bottom::music() + $transpose;

        keyboard\register( $kb, key = $bottom, expression = $music, hold = not $toggle, toggle = $toggle, extend = true );

        $bottom = $bottom + 1;
    };

    return $kb;
};

fun keyboard\repl ( $key = "\\", $ctx = none ) {
    $ctx = $ctx or getctx();

    return @keyboard release {
        [ $key ]: { withctx( $ctx, keyboard\open_repl() ) };
    };
};

fun keyboard\bufslot( $bf = keyboard\Buffer( start = false ), $key = "p" ) {
    return @keyboard {
        [ $key ]: {
            if ($bf::started) {
                $bf::stop();
            } else {
                $bf::clear();
                $bf::start();
            };
        };
    };
};

# '0', '1', '2', '3', '4', '5', '6', '7', '8', '9'
fun keyboard\bufpad( ref $buffers, $keys = @[ 82, 79, 80, 81, 126, 75, 76, 77, 71, 72, 73 ], $savename = "buffers.mkl", $load_key = 'f7', $save_key = 'f8' ) {
    $buffers = @{};

    $saving_file = false;
    $save_location = getcwd() + "/" + $savename;

    fun prompt_location ( $title, $cb ) {
        if ( not $saving_file ) {
            $saving_file = true;
            
            keyboard\filedialog( title = $title, default_value = $save_location, cb = fun ( $file ) {
                using( $save_location );

                $saving_file = false;

                if ( $file != none ) {
                    $save_location = $file;
                };

                $cb();
            } );
        };
    };

    fun load_buffers ( $interactive = true ) {
        if ( $interactive ) {
            prompt_location( "Open File", fun () => load_buffers( interactive = false ) );
        } else {
            $keyboard\Buffer::load_all( $save_location, $buffers ); 
        }
    };

    fun save_buffers ( $interactive = true ) {
        if ( $interactive ) {
            prompt_location( "Save File", fun () => save_buffers( interactive = false ) );
        } else {
            $keyboard\Buffer::save_all( $save_location, $buffers ); 
        }
    };

    $_kb = @keyboard {
        # Load
        [$load_key]: load_buffers();

        # Save
        [$save_key]: save_buffers();

        for ( $i in range( len( $keys ) ) ) {
            # Bind a variable with the key stored in the array at the given index
            { $key = $keys::[$i] };

            # Starts and stops the buffer from recording
            [ keyboard\KeyStroke( $key, ctrl = true ) ]: {
                $bf = $buffers::get( $i, none );

                if ($bf == none) {
                    $bf = keyboard\Buffer();

                    $buffers::set( $i, $bf );
                } else {
                    if ($bf::started) {
                        $bf::stop();
                    } else {
                        $bf::clear();
                        $bf::start();
                    };
                };
            };

            # Previews the recorded music sequence inside the buffer
            [ keyboard\KeyStroke( $key ) ] toggle: {
                $bf = $buffers::get( $i, none );
                
                if ($bf != none) {
                    return $bf::to_music();
                };
            };
        };
    };

    return pack( into = $_kb, exclude = @[ 'keys' ] );
};
