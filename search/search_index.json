{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Musikla Musikla is a domain-specific language to create dynamic music and music keyboards. Command Line usage: musikla [-h] [-i IMPORTS] [-o OUTPUTS] [--midi MIDI] [--soundfont SOUNDFONT] [--print-events] [file] positional arguments: file Files to evaluate. No file means the input will be read from the stdin optional arguments: -h, --help show this help message and exit -i IMPORTS, --import IMPORTS Import an additional library. These can be builtin libraries, or path to .ml and .py files -o OUTPUTS, --output OUTPUTS Where to output to. By default outputs the sounds to the device's speakers. --midi MIDI Use a custom MIDI port by default when no name is specified --soundfont SOUNDFONT Use a custom soundfont .sf2 file --print-events Print events (notes) to the console as they are played. mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs -h - Print help message and exit. Installation To install, clone the repository. Then go to the code/musikla/ folder and install with pip: git clone git@github.com:pedromsilvapt/miei-dissertation.git cd miei-dissertation/code/musikla pip3 install -e . Python Dependencies typeguard pynput mido python-rtmidi (requires libasound2-dev (or --install-option=\"--no-alsa\" ) and libjack-dev (or --install-option=\"--no-jack\" )) imgui[glfw] (requires libglfw3 and libglfw3-dev arpeggio pyFluidSynth (required fluidsynth >=1.1.9 ) Note Instead of installing pyFluidSynth from PyPi, we need to use the more up-to-date version (which accepts pulseaudio) from the git repo pip3 install git+https://github.com/pedromsilvapt/pyfluidsynth","title":"Home"},{"location":"#musikla","text":"Musikla is a domain-specific language to create dynamic music and music keyboards.","title":"Musikla"},{"location":"#command-line","text":"usage: musikla [-h] [-i IMPORTS] [-o OUTPUTS] [--midi MIDI] [--soundfont SOUNDFONT] [--print-events] [file] positional arguments: file Files to evaluate. No file means the input will be read from the stdin optional arguments: -h, --help show this help message and exit -i IMPORTS, --import IMPORTS Import an additional library. These can be builtin libraries, or path to .ml and .py files -o OUTPUTS, --output OUTPUTS Where to output to. By default outputs the sounds to the device's speakers. --midi MIDI Use a custom MIDI port by default when no name is specified --soundfont SOUNDFONT Use a custom soundfont .sf2 file --print-events Print events (notes) to the console as they are played. mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs -h - Print help message and exit.","title":"Command Line"},{"location":"#installation","text":"To install, clone the repository. Then go to the code/musikla/ folder and install with pip: git clone git@github.com:pedromsilvapt/miei-dissertation.git cd miei-dissertation/code/musikla pip3 install -e .","title":"Installation"},{"location":"#python-dependencies","text":"typeguard pynput mido python-rtmidi (requires libasound2-dev (or --install-option=\"--no-alsa\" ) and libjack-dev (or --install-option=\"--no-jack\" )) imgui[glfw] (requires libglfw3 and libglfw3-dev arpeggio pyFluidSynth (required fluidsynth >=1.1.9 ) Note Instead of installing pyFluidSynth from PyPi, we need to use the more up-to-date version (which accepts pulseaudio) from the git repo pip3 install git+https://github.com/pedromsilvapt/pyfluidsynth","title":"Python Dependencies"},{"location":"cookbook/keyboards/custom-keyboard/","text":"","title":"Custom Keyboards"},{"location":"cookbook/keyboards/midi-keyboard/","text":"","title":"MIDI Keyboards"},{"location":"cookbook/keyboards/paino-keyboard/","text":"","title":"Piano Keyboards"},{"location":"syntax/chords/","text":"Chords We've already covered how we can play multiple notes at the same time thanks to the parallel operator . However, there is a handy shortcut to produce chords, that also has the benefit of identifying semantically that those notes are indeed part of the same chord. 1 2 3 [ CFG ] / 2 [ CFG ] # Is roughly equivalent to ( C/2 | F/2 | G/2 ) ( C | F | G ) As can be seen, wrapping the notes in square brackets [ ] avoids the need to manually put all notes in parallel. It also avoids the need to set the length of each note manually. However, instead of typing each individual note of the chord, it is also possible to create a chord from a root note and specifying the type of chord needed. 1 [ Cm ] / 2 [ CM ] Chord Abbreviations As of now, the supported chord abbreviations are as follows: Group Abbreviations Triads M / m / aug / dim / + Sevenths m7 / M7 / dom7 / 7 / m7b5 / dim7 / mM7 Perfect Fifth 5","title":"Chords"},{"location":"syntax/chords/#chords","text":"We've already covered how we can play multiple notes at the same time thanks to the parallel operator . However, there is a handy shortcut to produce chords, that also has the benefit of identifying semantically that those notes are indeed part of the same chord. 1 2 3 [ CFG ] / 2 [ CFG ] # Is roughly equivalent to ( C/2 | F/2 | G/2 ) ( C | F | G ) As can be seen, wrapping the notes in square brackets [ ] avoids the need to manually put all notes in parallel. It also avoids the need to set the length of each note manually. However, instead of typing each individual note of the chord, it is also possible to create a chord from a root note and specifying the type of chord needed. 1 [ Cm ] / 2 [ CM ]","title":"Chords"},{"location":"syntax/chords/#chord-abbreviations","text":"As of now, the supported chord abbreviations are as follows: Group Abbreviations Triads M / m / aug / dim / + Sevenths m7 / M7 / dom7 / 7 / m7b5 / dim7 / mM7 Perfect Fifth 5","title":"Chord Abbreviations"},{"location":"syntax/combinators/","text":"Combinators We've already covered how to describe notes and rests, some of the basic building blocks of our language. It is useful to discuss how these blocks can be combined with each other, from single notes and rests to something more interesting. Sequential The most basic form of music composition is sequential: each value is played after the last one ends. To do this in our language, just write each value one after the other separated by whitespace. C F G Grouping Another possible combinator is grouping values with parenthesis ( ) . This is not very interesting in and of itself (simply grouping together a sequence of notes is exatcly the same as just playing the notes sequentially), grouping can be extremely powerful when employed alongside the other combinators. ( C F ) G Parallel Sequential notes can be played simply by writing them in a sequence (one after the other). Parallel notes, however, can be described by using a pipe separator | between them. C | G Since playing each note in parallel can become cumbersome, we can use groups to make the task more straighforward. ( C E | G B ) This example is equivalent to (C | G) (E | B) , which means the notes C and G play in parallel, and after, the notes E and B also play in parallel. Since the complexity of the expressions that compose the parallel operator can vary, and they are not required to have the same length (this is, to last the same time), the length of the entire parallel expression is always determined by the longer component. Repeat It is possible to repeat any musical element by using the multiply operator * . For instance, playing the not A five times could be acomplished like so A*5 . However, more interesting than repeating a single note, is repeating groups of notes. ( C F G ) * 2","title":"Combinators"},{"location":"syntax/combinators/#combinators","text":"We've already covered how to describe notes and rests, some of the basic building blocks of our language. It is useful to discuss how these blocks can be combined with each other, from single notes and rests to something more interesting.","title":"Combinators"},{"location":"syntax/combinators/#sequential","text":"The most basic form of music composition is sequential: each value is played after the last one ends. To do this in our language, just write each value one after the other separated by whitespace. C F G","title":"Sequential"},{"location":"syntax/combinators/#grouping","text":"Another possible combinator is grouping values with parenthesis ( ) . This is not very interesting in and of itself (simply grouping together a sequence of notes is exatcly the same as just playing the notes sequentially), grouping can be extremely powerful when employed alongside the other combinators. ( C F ) G","title":"Grouping"},{"location":"syntax/combinators/#parallel","text":"Sequential notes can be played simply by writing them in a sequence (one after the other). Parallel notes, however, can be described by using a pipe separator | between them. C | G Since playing each note in parallel can become cumbersome, we can use groups to make the task more straighforward. ( C E | G B ) This example is equivalent to (C | G) (E | B) , which means the notes C and G play in parallel, and after, the notes E and B also play in parallel. Since the complexity of the expressions that compose the parallel operator can vary, and they are not required to have the same length (this is, to last the same time), the length of the entire parallel expression is always determined by the longer component.","title":"Parallel"},{"location":"syntax/combinators/#repeat","text":"It is possible to repeat any musical element by using the multiply operator * . For instance, playing the not A five times could be acomplished like so A*5 . However, more interesting than repeating a single note, is repeating groups of notes. ( C F G ) * 2","title":"Repeat"},{"location":"syntax/notes-and-rests/","text":"Notes & Rests In Musikla, notes are first-class primitives, just like numbers or strings or booleans are in most programming languages. This means we can put notes anywhere a value is expected, without the need for any special syntax. Also of note, any notes that are not stored in a variable or passed to a function are played automatically. Calling the play() function is optional. Notes Notes are represented by the letters C , D , E , F , G , A and B . Middle C , also known as C4 , is represented by C . Octaves To lower the octave, we can add commas , after the note. To up one octave, we can first use the lower case letter c , and to up further we can add apostrophes ' after the letter. Here is a full scale of C's: C,,,, C,,, C,, C, C c c' c'' c''' c'''' c''''' The lowest possible note is C,,,, and the highest is g''''' . Accidentals It is possible to describe accidentals by prefixing the note with either ^^ , ^ , _ or __ . Thus, it is possible to represent all the keys in a piano like so: C ^C D ^D E ^F F ^G G ^A A B Note In practice ^^C == D and __D == C ; Note Lengths Not all notes have the same length (or duration). The default length of all notes is 1 beat. This can be changed by appending the note with its length. C1/2 (or the equivalent C/2 ) describes a half note (or a minim ) C1 (or the equivalent C ) describes a whole note (or a semibreve ) C2 describes a double whole note (or a breve ) The actual duration of the note (in seconds) is determined by the beats per minute ( BPM ) and the time signature of the current voice . Rests Rests allow us to describe pauses: moments of silence between notes. They are described by the letter r . The length of a rest can be described in the same way as the length of a note . c2 r3/4 c","title":"Notes & Rests"},{"location":"syntax/notes-and-rests/#notes-rests","text":"In Musikla, notes are first-class primitives, just like numbers or strings or booleans are in most programming languages. This means we can put notes anywhere a value is expected, without the need for any special syntax. Also of note, any notes that are not stored in a variable or passed to a function are played automatically. Calling the play() function is optional.","title":"Notes &amp; Rests"},{"location":"syntax/notes-and-rests/#notes","text":"Notes are represented by the letters C , D , E , F , G , A and B . Middle C , also known as C4 , is represented by C .","title":"Notes"},{"location":"syntax/notes-and-rests/#octaves","text":"To lower the octave, we can add commas , after the note. To up one octave, we can first use the lower case letter c , and to up further we can add apostrophes ' after the letter. Here is a full scale of C's: C,,,, C,,, C,, C, C c c' c'' c''' c'''' c''''' The lowest possible note is C,,,, and the highest is g''''' .","title":"Octaves"},{"location":"syntax/notes-and-rests/#accidentals","text":"It is possible to describe accidentals by prefixing the note with either ^^ , ^ , _ or __ . Thus, it is possible to represent all the keys in a piano like so: C ^C D ^D E ^F F ^G G ^A A B Note In practice ^^C == D and __D == C ;","title":"Accidentals"},{"location":"syntax/notes-and-rests/#note-lengths","text":"Not all notes have the same length (or duration). The default length of all notes is 1 beat. This can be changed by appending the note with its length. C1/2 (or the equivalent C/2 ) describes a half note (or a minim ) C1 (or the equivalent C ) describes a whole note (or a semibreve ) C2 describes a double whole note (or a breve ) The actual duration of the note (in seconds) is determined by the beats per minute ( BPM ) and the time signature of the current voice .","title":"Note Lengths"},{"location":"syntax/notes-and-rests/#rests","text":"Rests allow us to describe pauses: moments of silence between notes. They are described by the letter r . The length of a rest can be described in the same way as the length of a note . c2 r3/4 c","title":"Rests"},{"location":"syntax/programming/","text":"Programming A musikla script is just a sequence of statements ( and expressions ). Each statement must be followed by a ; , even if it ends in brackes { and } like an if or while . Variables Variables can stored and accessed by prefixing their name with a dollar sign `$. 1 2 3 $var_name = true ; print ( $var_name == null or $var_name == false ); Function Declarations Functions are declared with the fun keyword, followed by an optional function name. Function declarations are expressions that return a reference to the newly created function. This means that they can be saved in variables, passed as parameters to other functions, or otherwise used anywhere an expression could generally be used. 1 2 3 fun hello_world ( $name = 'User' ) { return 'Hello ' + $name; }; Function bodies can be multiline (like in the example above, surrounded by brackets { } ) or single line indicated by an arrow => 1 fun hello_world ( $name = 'User' ) => 'Hello ' + $name; Reference Arguments Function arguments can be declared as ref , meaning that any changes done to them will be reflected on the variable outside the function. Reference 1 2 3 4 5 6 7 8 9 fun increment ( ref $var ) { $var += 1; }; $a = 0; inc( $a ); print( $a ); # prints 1 If/Else Right now else if 's are not supported. The else block is optional, of course. 1 2 3 4 5 if ( $condition ) { print ( 1 ); } else { print ( 2 ); }; While 1 2 3 while ( $condition ) { print ( 1 ); }; For 1 2 3 for ( $item in $collection ) { print ( $item ); }; Arrays Arrays are a very common construct in programming languages, and they have proven very useful here as well. Array literals can be constructed with the syntax @[] 1 2 3 4 5 6 7 8 9 $array = @ [ 1 , 2 , 3 , 4 ]; # Iterate over the array for ( $i in $array ) { print ( $i ); }; # Print the first and last element of the array print ( $array :: [ 0 ], $array :: [ - 1 ] ); Dictionaries Similar to arrays, dictionary literals can be constructed with the syntax @{} 1 $dict = @ { foo = 1 , bar = true , get = 1 }; Dictionaries have four methods: has() , get() , set() and delete() . For convenience, their values can also be accessed using the regular property accessor syntax. 1 2 3 4 5 6 7 8 9 10 11 # We check if the key exists, and access it directly if ( $dict :: has ( 'foo' ) ) { print ( $dict :: foo ); }; # With the `get` method we can provide a default value print ( $dict :: get ( 'foo' , default = null ) ); $dict :: set ( 'bar' , false ); $dict :: delete ( 'foo' );","title":"Programming"},{"location":"syntax/programming/#programming","text":"A musikla script is just a sequence of statements ( and expressions ). Each statement must be followed by a ; , even if it ends in brackes { and } like an if or while .","title":"Programming"},{"location":"syntax/programming/#variables","text":"Variables can stored and accessed by prefixing their name with a dollar sign `$. 1 2 3 $var_name = true ; print ( $var_name == null or $var_name == false );","title":"Variables"},{"location":"syntax/programming/#function-declarations","text":"Functions are declared with the fun keyword, followed by an optional function name. Function declarations are expressions that return a reference to the newly created function. This means that they can be saved in variables, passed as parameters to other functions, or otherwise used anywhere an expression could generally be used. 1 2 3 fun hello_world ( $name = 'User' ) { return 'Hello ' + $name; }; Function bodies can be multiline (like in the example above, surrounded by brackets { } ) or single line indicated by an arrow => 1 fun hello_world ( $name = 'User' ) => 'Hello ' + $name;","title":"Function Declarations"},{"location":"syntax/programming/#reference-arguments","text":"Function arguments can be declared as ref , meaning that any changes done to them will be reflected on the variable outside the function. Reference 1 2 3 4 5 6 7 8 9 fun increment ( ref $var ) { $var += 1; }; $a = 0; inc( $a ); print( $a ); # prints 1","title":"Reference Arguments"},{"location":"syntax/programming/#ifelse","text":"Right now else if 's are not supported. The else block is optional, of course. 1 2 3 4 5 if ( $condition ) { print ( 1 ); } else { print ( 2 ); };","title":"If/Else"},{"location":"syntax/programming/#while","text":"1 2 3 while ( $condition ) { print ( 1 ); };","title":"While"},{"location":"syntax/programming/#for","text":"1 2 3 for ( $item in $collection ) { print ( $item ); };","title":"For"},{"location":"syntax/programming/#arrays","text":"Arrays are a very common construct in programming languages, and they have proven very useful here as well. Array literals can be constructed with the syntax @[] 1 2 3 4 5 6 7 8 9 $array = @ [ 1 , 2 , 3 , 4 ]; # Iterate over the array for ( $i in $array ) { print ( $i ); }; # Print the first and last element of the array print ( $array :: [ 0 ], $array :: [ - 1 ] );","title":"Arrays"},{"location":"syntax/programming/#dictionaries","text":"Similar to arrays, dictionary literals can be constructed with the syntax @{} 1 $dict = @ { foo = 1 , bar = true , get = 1 }; Dictionaries have four methods: has() , get() , set() and delete() . For convenience, their values can also be accessed using the regular property accessor syntax. 1 2 3 4 5 6 7 8 9 10 11 # We check if the key exists, and access it directly if ( $dict :: has ( 'foo' ) ) { print ( $dict :: foo ); }; # With the `get` method we can provide a default value print ( $dict :: get ( 'foo' , default = null ) ); $dict :: set ( 'bar' , false ); $dict :: delete ( 'foo' );","title":"Dictionaries"},{"location":"syntax/sound-files/","text":"Sound Files We've seen how to play notes and chords from instruments, but sometimes it can be interesting to mix things up a bit and play sound files directly. Sound files can be played just like notes, and to do so, they simply have to be loaded first. 1 A B sample ( \"cihat.wav\" ); To avoid loading the sample every time, we can load it once and save it in a variable . 1 2 3 $cihat = sample ( \"cihat.wav\" ); A B $cihat ; The sound files can be in virtually any common format. If they are already optimized, they are loaded straight away. If not, they are converted in runtime in memory using FFMPEG in the background. NOTE Optimizing files in the background requires FFMPEG to be installed and available in the $PATH . Optimal Format Sound files in this format do not require any kind of preprocessing and can be loaded directly into memory, minimizing the performance overhead. When possible, use of convert files to this format. Setting Value Format WAVE Sample Rate 41.100hz Channels 1 ( Mono ) Bit depth 16bit Compression None Optimizing When the file format is not optimal, optimizing it beforehand can make the whole program more performant and reduce load times. To simplify the experience, and to avoid forcing the user to figure out what tool to use and what configurations to apply to convert the files, the language comes equipped with two utility functions that simplify this process. The user simply has to provide the file or folder paths containing the files he wishes to optimize, and indicate where the optimized versions should be saved. 1 2 3 4 5 6 # Converts a single file and stores it in the given path optimize_sample ( \"cihat.mp3\" , \"cihat.mp3\" ); # Converts every file inside the `samples/` folder into an optimized version #and stores them, with the same name inside the `samples-optimized/` folder. optimize_samples_folder ( \"samples/\" , \"samples-optimized/\" );","title":"Sound Files"},{"location":"syntax/sound-files/#sound-files","text":"We've seen how to play notes and chords from instruments, but sometimes it can be interesting to mix things up a bit and play sound files directly. Sound files can be played just like notes, and to do so, they simply have to be loaded first. 1 A B sample ( \"cihat.wav\" ); To avoid loading the sample every time, we can load it once and save it in a variable . 1 2 3 $cihat = sample ( \"cihat.wav\" ); A B $cihat ; The sound files can be in virtually any common format. If they are already optimized, they are loaded straight away. If not, they are converted in runtime in memory using FFMPEG in the background. NOTE Optimizing files in the background requires FFMPEG to be installed and available in the $PATH .","title":"Sound Files"},{"location":"syntax/sound-files/#optimal-format","text":"Sound files in this format do not require any kind of preprocessing and can be loaded directly into memory, minimizing the performance overhead. When possible, use of convert files to this format. Setting Value Format WAVE Sample Rate 41.100hz Channels 1 ( Mono ) Bit depth 16bit Compression None","title":"Optimal Format"},{"location":"syntax/sound-files/#optimizing","text":"When the file format is not optimal, optimizing it beforehand can make the whole program more performant and reduce load times. To simplify the experience, and to avoid forcing the user to figure out what tool to use and what configurations to apply to convert the files, the language comes equipped with two utility functions that simplify this process. The user simply has to provide the file or folder paths containing the files he wishes to optimize, and indicate where the optimized versions should be saved. 1 2 3 4 5 6 # Converts a single file and stores it in the given path optimize_sample ( \"cihat.mp3\" , \"cihat.mp3\" ); # Converts every file inside the `samples/` folder into an optimized version #and stores them, with the same name inside the `samples-optimized/` folder. optimize_samples_folder ( \"samples/\" , \"samples-optimized/\" );","title":"Optimizing"},{"location":"syntax/voices/","text":"Voices Voices allow a easy way of grouping notes and applying settings to all of them, such as the volume or instrument. By default, there is already one voice created and all notes played are played in that voice. Modifiers To change the settings of a voice, we make use of modifiers . Modifiers can be used anywhere notes can, and can be even used in the middle of notes. 1 S4/4 L1/4 V90 One interesting aspect is that by using groups , we can apply those modifiers to just a subset of notes. In the example below, we can see how to apply a change in volume v50 to only the notes that are inside the parenthesis. 1 C ( v50 F ) G Modifier Description S4/4 Changes the time signature to 4/4 . L2 L1/2 Sets the base note length . Each note's length is then calculated as a multiplier of this value. T120 Changes the tempo to 120 beats per minute ( BPM ). O1 Sets the base octave to 1 . C becomes C1 (instead of C4 ) and all other notes change as well I1 Change the voice's instrument to be the number 1 (usually follows the General MIDI Standard Named Voices Sometimes instead of changing the settings of the voice in everyplace we need them, we might want to create named voices. These voices can have default settings that are automatically applied when we change to that voice. Voice names are prepended by a colon : . The simplest voice declaration is to just define the name and instrument to be used. Using the name we just created, we can then change the voice anywhere. 1 2 3 :violin = I41 ; C F G ( :violin c f g ); However, voices can also be used to change more than just the instrument. We can pass them a sequence of modifiers as well, and they will be applied by default to the voice. Optionally, we can inherit those settings from other voices, to avoid typing them out one by one. 1 2 :piano = I1 S6/8 T140 L/8 V120 ; :violin = :piano ( I41 ); NOTE This syntax is slightly different from the current implementation.","title":"Voices"},{"location":"syntax/voices/#voices","text":"Voices allow a easy way of grouping notes and applying settings to all of them, such as the volume or instrument. By default, there is already one voice created and all notes played are played in that voice.","title":"Voices"},{"location":"syntax/voices/#modifiers","text":"To change the settings of a voice, we make use of modifiers . Modifiers can be used anywhere notes can, and can be even used in the middle of notes. 1 S4/4 L1/4 V90 One interesting aspect is that by using groups , we can apply those modifiers to just a subset of notes. In the example below, we can see how to apply a change in volume v50 to only the notes that are inside the parenthesis. 1 C ( v50 F ) G Modifier Description S4/4 Changes the time signature to 4/4 . L2 L1/2 Sets the base note length . Each note's length is then calculated as a multiplier of this value. T120 Changes the tempo to 120 beats per minute ( BPM ). O1 Sets the base octave to 1 . C becomes C1 (instead of C4 ) and all other notes change as well I1 Change the voice's instrument to be the number 1 (usually follows the General MIDI Standard","title":"Modifiers"},{"location":"syntax/voices/#named-voices","text":"Sometimes instead of changing the settings of the voice in everyplace we need them, we might want to create named voices. These voices can have default settings that are automatically applied when we change to that voice. Voice names are prepended by a colon : . The simplest voice declaration is to just define the name and instrument to be used. Using the name we just created, we can then change the voice anywhere. 1 2 3 :violin = I41 ; C F G ( :violin c f g ); However, voices can also be used to change more than just the instrument. We can pass them a sequence of modifiers as well, and they will be applied by default to the voice. Optionally, we can inherit those settings from other voices, to avoid typing them out one by one. 1 2 :piano = I1 S6/8 T140 L/8 V120 ; :violin = :piano ( I41 ); NOTE This syntax is slightly different from the current implementation.","title":"Named Voices"}]}