{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Musikla Musikla is a domain-specific language to create dynamic music and music keyboards. Command Line usage: musikla [-h] [-i IMPORTS] [-o OUTPUTS] [--midi MIDI] [--soundfont SOUNDFONT] [--print-events] [file] positional arguments: file Files to evaluate. No file means the input will be read from the stdin optional arguments: -h, --help show this help message and exit -i IMPORTS, --import IMPORTS Import an additional library. These can be builtin libraries, or path to .ml and .py files -o OUTPUTS, --output OUTPUTS Where to output to. By default outputs the sounds to the device's speakers. --midi MIDI Use a custom MIDI port by default when no name is specified --soundfont SOUNDFONT Use a custom soundfont .sf2 file --print-events Print events (notes) to the console as they are played. Installation To install, clone the repository. Then go to the code/musikla/ folder and install with pip: git clone git@github.com:pedromsilvapt/miei-dissertation.git cd miei-dissertation/code/musikla pip3 install -e . Python Dependencies typeguard pynput mido python-rtmidi (requires libasound2-dev (or --install-option=\"--no-alsa\" ) and libjack-dev (or --install-option=\"--no-jack\" )) imgui[glfw] (requires libglfw3 and libglfw3-dev arpeggio pyFluidSynth (required fluidsynth >=1.1.9 ) Note Instead of installing pyFluidSynth from PyPi, we need to use the more up-to-date version (which accepts pulseaudio) from the git repo pip3 install git+https://github.com/pedromsilvapt/pyfluidsynth","title":"Home"},{"location":"#musikla","text":"Musikla is a domain-specific language to create dynamic music and music keyboards.","title":"Musikla"},{"location":"#command-line","text":"usage: musikla [-h] [-i IMPORTS] [-o OUTPUTS] [--midi MIDI] [--soundfont SOUNDFONT] [--print-events] [file] positional arguments: file Files to evaluate. No file means the input will be read from the stdin optional arguments: -h, --help show this help message and exit -i IMPORTS, --import IMPORTS Import an additional library. These can be builtin libraries, or path to .ml and .py files -o OUTPUTS, --output OUTPUTS Where to output to. By default outputs the sounds to the device's speakers. --midi MIDI Use a custom MIDI port by default when no name is specified --soundfont SOUNDFONT Use a custom soundfont .sf2 file --print-events Print events (notes) to the console as they are played.","title":"Command Line"},{"location":"#installation","text":"To install, clone the repository. Then go to the code/musikla/ folder and install with pip: git clone git@github.com:pedromsilvapt/miei-dissertation.git cd miei-dissertation/code/musikla pip3 install -e .","title":"Installation"},{"location":"#python-dependencies","text":"typeguard pynput mido python-rtmidi (requires libasound2-dev (or --install-option=\"--no-alsa\" ) and libjack-dev (or --install-option=\"--no-jack\" )) imgui[glfw] (requires libglfw3 and libglfw3-dev arpeggio pyFluidSynth (required fluidsynth >=1.1.9 ) Note Instead of installing pyFluidSynth from PyPi, we need to use the more up-to-date version (which accepts pulseaudio) from the git repo pip3 install git+https://github.com/pedromsilvapt/pyfluidsynth","title":"Python Dependencies"},{"location":"paper/","text":"Semantics of Implicitly Timed Musical Events In this paper, we'll discuss a simple approach to designing a language for generating musical events. One of the principal characteristics of said events is both their start time as well as their duration. The most straightforward way for implementing is to let the user control the timing manually: setting both properties (start and duration) manually for each event. This is the approach used by some of the existing languages in this space, such as SonicPi . This is very cumbersome and prone to errors, though, as one could guess from the following usecase. If the user wants to change one of the earlier events, he would have to manually update the timings. Instead, we'll take a look at an alternative approach based on custom operators, each with their own semantic and syntax that enable an expressive way to define those events. But more that just being able to define those events, we will also be interested in exploring how well they integrate with existing and common programming language constructs, like variables, functions, loops and other control structures. Requirements There are two important requirements we need to consider when evaluating possible solutions to this problem: the ability to produce music interactively, and to produce music lazily. The first requirement, interactivity , relates to our goal of not only being able to generate music offline, but also in a live environment: give the user the ability to program several snippets of musical events, and then control them through a virtual keyboard or through other interactive means. The second requirement, laziness , refers to a concept that is familiar in functional programming languages: values are generated when we need them, not earlier. In our case, this implies that a musical sequence could be potentially infinite (like an infinite repetition of some arrangement). If playing this music live, the musician could determine when to stop this arrangement sooner or later. Given these two requirements, we can conclude we cannot generate all music events at the start and then play them in order. Lemma It must produce events in a sorted fashion. Interactivity means we must start playing the music before it has been completly generated.","title":"Semantics of Implicitly Timed Musical Events"},{"location":"paper/#semantics-of-implicitly-timed-musical-events","text":"In this paper, we'll discuss a simple approach to designing a language for generating musical events. One of the principal characteristics of said events is both their start time as well as their duration. The most straightforward way for implementing is to let the user control the timing manually: setting both properties (start and duration) manually for each event. This is the approach used by some of the existing languages in this space, such as SonicPi . This is very cumbersome and prone to errors, though, as one could guess from the following usecase. If the user wants to change one of the earlier events, he would have to manually update the timings. Instead, we'll take a look at an alternative approach based on custom operators, each with their own semantic and syntax that enable an expressive way to define those events. But more that just being able to define those events, we will also be interested in exploring how well they integrate with existing and common programming language constructs, like variables, functions, loops and other control structures.","title":"Semantics of Implicitly Timed Musical Events"},{"location":"paper/#requirements","text":"There are two important requirements we need to consider when evaluating possible solutions to this problem: the ability to produce music interactively, and to produce music lazily. The first requirement, interactivity , relates to our goal of not only being able to generate music offline, but also in a live environment: give the user the ability to program several snippets of musical events, and then control them through a virtual keyboard or through other interactive means. The second requirement, laziness , refers to a concept that is familiar in functional programming languages: values are generated when we need them, not earlier. In our case, this implies that a musical sequence could be potentially infinite (like an infinite repetition of some arrangement). If playing this music live, the musician could determine when to stop this arrangement sooner or later. Given these two requirements, we can conclude we cannot generate all music events at the start and then play them in order. Lemma It must produce events in a sorted fashion. Interactivity means we must start playing the music before it has been completly generated.","title":"Requirements"},{"location":"api/keyboard/","text":"","title":"keyboard"},{"location":"api/music/","text":"music Functions specificly related to the Music data type are contained in this module. NOTE This module is automatically imported for all scripts, and thus never needs to be manually imported. Functions cc( control : int, value : int ) Emits a ControlChangeEvent for the current voice. The controls available and their valid values are the taken from the MIDI specification are listed here . 1 2 3 4 # Sustain On cc ( 64 , 127 ); # Sustain Off cc ( 64 , 0 ); setvoice( voice : Voice ) Changes the current voice to the voice given. Note that the voice should be passed as a variable (with a $ prefix) instead of the usual : voice prefix. 1 2 3 :violin = 41 ; setvoice ( $violin ); setinstrument( instrument : int ) Keeps the same voice but changes it's instrument. Expects a number representing the intrument ID (usually follows the General MIDI specification). 1 setinstrument ( 41 ); interval( semitones : int = 0, octaves : int = 0 ) Creates an interval with the given semitones and octaves. Both parameters are optional, and can be used as positional or named parameters. 1 2 3 4 5 6 # An interval with three semitones $int = interval ( 3 ); # An interval with two octaves $int = interval ( octaves = 2 ); # An interval with two octaves and three semitones $int = interval ( 3 , 2 ); Intervals can be added and subtracted with each other, as well as with plain integers (treated as semitones). 1 2 3 4 # An interval with three semitones $int = interval ( 3 ); print ( ( $int + 1 ) :: semitones ) # prints out 4 They can also be added to Music sequences or single note events, effectively transposing the notes with the given interval. 1 2 3 4 5 # Adds two semitones play ( ( C F G ) + 2 ); # Adds two octaves play ( ( C F G ) + interval ( octaves = 2 ) ); scale ( intervals : List[int] ) Creates a scale with the given intervals. There are two predefined scales, $scales::white_keys and $scales::black_keys . The scales wrap around, going up octaves or down, when the index is negative. 1 2 3 play ( C + $scale :: white_keys :: [ 1 ] ) # will play D play ( C + $scale :: white_keys :: [ 8 ] ) # will play d","title":"music"},{"location":"api/music/#music","text":"Functions specificly related to the Music data type are contained in this module. NOTE This module is automatically imported for all scripts, and thus never needs to be manually imported.","title":"music"},{"location":"api/music/#functions","text":"","title":"Functions"},{"location":"api/music/#cc-control-int-value-int","text":"Emits a ControlChangeEvent for the current voice. The controls available and their valid values are the taken from the MIDI specification are listed here . 1 2 3 4 # Sustain On cc ( 64 , 127 ); # Sustain Off cc ( 64 , 0 );","title":"cc( control : int, value : int )"},{"location":"api/music/#setvoice-voice-voice","text":"Changes the current voice to the voice given. Note that the voice should be passed as a variable (with a $ prefix) instead of the usual : voice prefix. 1 2 3 :violin = 41 ; setvoice ( $violin );","title":"setvoice( voice : Voice )"},{"location":"api/music/#setinstrument-instrument-int","text":"Keeps the same voice but changes it's instrument. Expects a number representing the intrument ID (usually follows the General MIDI specification). 1 setinstrument ( 41 );","title":"setinstrument( instrument : int )"},{"location":"api/music/#interval-semitones-int-0-octaves-int-0","text":"Creates an interval with the given semitones and octaves. Both parameters are optional, and can be used as positional or named parameters. 1 2 3 4 5 6 # An interval with three semitones $int = interval ( 3 ); # An interval with two octaves $int = interval ( octaves = 2 ); # An interval with two octaves and three semitones $int = interval ( 3 , 2 ); Intervals can be added and subtracted with each other, as well as with plain integers (treated as semitones). 1 2 3 4 # An interval with three semitones $int = interval ( 3 ); print ( ( $int + 1 ) :: semitones ) # prints out 4 They can also be added to Music sequences or single note events, effectively transposing the notes with the given interval. 1 2 3 4 5 # Adds two semitones play ( ( C F G ) + 2 ); # Adds two octaves play ( ( C F G ) + interval ( octaves = 2 ) );","title":"interval( semitones : int = 0, octaves : int = 0 )"},{"location":"api/music/#scale-intervals-listint","text":"Creates a scale with the given intervals. There are two predefined scales, $scales::white_keys and $scales::black_keys . The scales wrap around, going up octaves or down, when the index is negative. 1 2 3 play ( C + $scale :: white_keys :: [ 1 ] ) # will play D play ( C + $scale :: white_keys :: [ 8 ] ) # will play d","title":"scale ( intervals : List[int] )"},{"location":"api/std/","text":"std This module contains the most common and basic functions. Those functions are always available and don't require a custom import. Functions print( *args ) The standard Python print function. debug( value ) Similar to print , but handles musical sequences differently (iterating over them and printing the notes/music events inside them). discard( value ) Simply consumes the value but does not return it. Useful when the value is a musical expression, since musical expressions that are used as statements are implicitly played. 1 2 3 4 5 6 C F G ; # Is implicitly equivalent to play ( C F G ); # If we did not want to play them we could use discard ( C F G ); While using this function with literal musical values might seem pointless, it can be useful when calling custom functions that might return music but also have some sort of side effects. With discard, we can execute those side effects without playing the music. 1 2 3 4 5 6 7 8 9 10 11 12 13 fun custom_function ( ref $count ) { $count += 1; play( C F G ); }; $i = 0; # No music will be played here discard( custom_function( $i ) ); # But the value of $i is changed to 1 print( $i ); using( variable ) When running code inside a function, any variable assignment is assumed to refer to a local variables (similar to the behavior of functions in Python). However, if we wanted to use a global variable inside our function, we need to specifically state we are using it. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 $global = 0 ; fun without_using () { $global = 1; }; fun with_using () { using( $global ); $global = 1; }; without_using(); print( $global ); # prints 0, global isn't changed with_using(); print( $global ); # prints 1, global is changed mod ( n : float, d : float ) Calculates the modulo. Similar to the % python operator. 1 2 # Equivalent to `5 % 2` in python mod ( 5 , 2 ); div ( n : float, d : float ) Calculates the integer division. Similar to the // python operator. 1 2 # Equivalent to `5 // 2` in python div ( 5 , 2 ); ord ( char : str ) Returns an integer corresponding to the character provided. 1 print ( ord ( 'A' ) ); # 65 chr ( n : integer ) Returns the character corresponding to the integer provided. 1 print ( chr ( 65 ) ); # 'A' gettime () Return the current timestamp in milliseconds settime ( time : int ) Set the current timestamp to time , in milliseconds. Use with care so as to not break the principle or ordered events.","title":"std"},{"location":"api/std/#std","text":"This module contains the most common and basic functions. Those functions are always available and don't require a custom import.","title":"std"},{"location":"api/std/#functions","text":"","title":"Functions"},{"location":"api/std/#print-args","text":"The standard Python print function.","title":"print( *args )"},{"location":"api/std/#debug-value","text":"Similar to print , but handles musical sequences differently (iterating over them and printing the notes/music events inside them).","title":"debug( value )"},{"location":"api/std/#discard-value","text":"Simply consumes the value but does not return it. Useful when the value is a musical expression, since musical expressions that are used as statements are implicitly played. 1 2 3 4 5 6 C F G ; # Is implicitly equivalent to play ( C F G ); # If we did not want to play them we could use discard ( C F G ); While using this function with literal musical values might seem pointless, it can be useful when calling custom functions that might return music but also have some sort of side effects. With discard, we can execute those side effects without playing the music. 1 2 3 4 5 6 7 8 9 10 11 12 13 fun custom_function ( ref $count ) { $count += 1; play( C F G ); }; $i = 0; # No music will be played here discard( custom_function( $i ) ); # But the value of $i is changed to 1 print( $i );","title":"discard( value )"},{"location":"api/std/#using-variable","text":"When running code inside a function, any variable assignment is assumed to refer to a local variables (similar to the behavior of functions in Python). However, if we wanted to use a global variable inside our function, we need to specifically state we are using it. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 $global = 0 ; fun without_using () { $global = 1; }; fun with_using () { using( $global ); $global = 1; }; without_using(); print( $global ); # prints 0, global isn't changed with_using(); print( $global ); # prints 1, global is changed","title":"using( variable )"},{"location":"api/std/#mod-n-float-d-float","text":"Calculates the modulo. Similar to the % python operator. 1 2 # Equivalent to `5 % 2` in python mod ( 5 , 2 );","title":"mod ( n : float, d : float )"},{"location":"api/std/#div-n-float-d-float","text":"Calculates the integer division. Similar to the // python operator. 1 2 # Equivalent to `5 // 2` in python div ( 5 , 2 );","title":"div ( n : float, d : float )"},{"location":"api/std/#ord-char-str","text":"Returns an integer corresponding to the character provided. 1 print ( ord ( 'A' ) ); # 65","title":"ord ( char : str )"},{"location":"api/std/#chr-n-integer","text":"Returns the character corresponding to the integer provided. 1 print ( chr ( 65 ) ); # 'A'","title":"chr ( n : integer )"},{"location":"api/std/#gettime","text":"Return the current timestamp in milliseconds","title":"gettime ()"},{"location":"api/std/#settime-time-int","text":"Set the current timestamp to time , in milliseconds. Use with care so as to not break the principle or ordered events.","title":"settime ( time : int )"},{"location":"cookbook/midi-output-waveform/","text":"Recording to Traktion Waveform The default way of playing sounds in Musikla is through the embedded fluidsynth library and a soundfont file. However, other ways of playing the audio are supported. One of those ways is emitting MIDI data to an open port that can then be played by any supporting device or application. In this tutorial, we'll explore how to connect the musikla MIDI events to the Traktion Waveform FREE software. Prerequisites Other than having both musikla and Traktion WaveForm installed, the user may need some additional software installed. loopMIDI Musikla does not suport virtual MIDI ports out of the box for some platforms (like Windows). This application can be used to easily create multiple virtual ports. Juicy SF A good easy-to-use SoundFont VST plugin that supports both 32bit and 64bit. GeneralUser GS A good and free soundfont to use Step 1: The Code Any valid musikla file should work, but if you want to try this out and don't have any, you can just use this small sample. 1 2 3 4 5 6 7 8 :piano = I1 S6/8 T140 L/8 V120 ; :violin = :piano ( I41 ); $chorus = :piano ( A * 11 G F * 12 | A,6 A,5 G, F,6 * 2 ) * 3 ; $melody = :piano ( r24 ( :violin a3 c'3 d'3 e'9 ) r9 e'3 d'3 c'3 a9 ); play ( $chorus | $melody ); Step 2: Configuring WaveForm MIDI After you've created at least one virtual MIDI port in loopMIDI, you can also create additional virtual ports inside WaveForm and filter what channels each port gets. Step 3: Configuring WaveForm Tracks Step 4: Running Musikla","title":"Recording to Traktion Waveform"},{"location":"cookbook/midi-output-waveform/#recording-to-traktion-waveform","text":"The default way of playing sounds in Musikla is through the embedded fluidsynth library and a soundfont file. However, other ways of playing the audio are supported. One of those ways is emitting MIDI data to an open port that can then be played by any supporting device or application. In this tutorial, we'll explore how to connect the musikla MIDI events to the Traktion Waveform FREE software.","title":"Recording to Traktion Waveform"},{"location":"cookbook/midi-output-waveform/#prerequisites","text":"Other than having both musikla and Traktion WaveForm installed, the user may need some additional software installed. loopMIDI Musikla does not suport virtual MIDI ports out of the box for some platforms (like Windows). This application can be used to easily create multiple virtual ports. Juicy SF A good easy-to-use SoundFont VST plugin that supports both 32bit and 64bit. GeneralUser GS A good and free soundfont to use","title":"Prerequisites"},{"location":"cookbook/midi-output-waveform/#step-1-the-code","text":"Any valid musikla file should work, but if you want to try this out and don't have any, you can just use this small sample. 1 2 3 4 5 6 7 8 :piano = I1 S6/8 T140 L/8 V120 ; :violin = :piano ( I41 ); $chorus = :piano ( A * 11 G F * 12 | A,6 A,5 G, F,6 * 2 ) * 3 ; $melody = :piano ( r24 ( :violin a3 c'3 d'3 e'9 ) r9 e'3 d'3 c'3 a9 ); play ( $chorus | $melody );","title":"Step 1: The Code"},{"location":"cookbook/midi-output-waveform/#step-2-configuring-waveform-midi","text":"After you've created at least one virtual MIDI port in loopMIDI, you can also create additional virtual ports inside WaveForm and filter what channels each port gets.","title":"Step 2: Configuring WaveForm MIDI"},{"location":"cookbook/midi-output-waveform/#step-3-configuring-waveform-tracks","text":"","title":"Step 3: Configuring WaveForm Tracks"},{"location":"cookbook/midi-output-waveform/#step-4-running-musikla","text":"","title":"Step 4: Running Musikla"},{"location":"cookbook/multiple-outputs/","text":"Multiple Outputs By default musikla plays the notes through fluidsynth to whatever sound output device the computer has. However, we can provide one output to replace that, or event more. Right now, there are multiple outputs supported: Sound Devices (such as pulseaudio , alsa , etc...) (format fluidsynth ) WAV Files (format fluidsynth ) MIDI Files/Ports (format midi ) ABC Files (format abc ) HTML files (through $ABC_UI ) (format html ) Each output can be specified through the -o or --output options in the command line. Usually the type of output is inferred, but it can be forced through the -f or --format option right after the output. Any additional options after the -o and either until the end of the command or until the next output will be forward to the current output only. Examples The following command will output to a ALSA device and at the same time will create a virtual MIDI port named custom_port , that will received only events for the voice piano . 1 2 3 musikla song.mkl \\ --output alsa --audio-bufcount 4 --gain 1 \\ --output custom_port --format midi --virtual --voice piano","title":"Multiple Outputs"},{"location":"cookbook/multiple-outputs/#multiple-outputs","text":"By default musikla plays the notes through fluidsynth to whatever sound output device the computer has. However, we can provide one output to replace that, or event more. Right now, there are multiple outputs supported: Sound Devices (such as pulseaudio , alsa , etc...) (format fluidsynth ) WAV Files (format fluidsynth ) MIDI Files/Ports (format midi ) ABC Files (format abc ) HTML files (through $ABC_UI ) (format html ) Each output can be specified through the -o or --output options in the command line. Usually the type of output is inferred, but it can be forced through the -f or --format option right after the output. Any additional options after the -o and either until the end of the command or until the next output will be forward to the current output only.","title":"Multiple Outputs"},{"location":"cookbook/multiple-outputs/#examples","text":"The following command will output to a ALSA device and at the same time will create a virtual MIDI port named custom_port , that will received only events for the voice piano . 1 2 3 musikla song.mkl \\ --output alsa --audio-bufcount 4 --gain 1 \\ --output custom_port --format midi --virtual --voice piano","title":"Examples"},{"location":"cookbook/keyboards/custom-keyboard/","text":"","title":"Custom Keyboards"},{"location":"cookbook/keyboards/midi-keyboard/","text":"","title":"MIDI Keyboards"},{"location":"cookbook/keyboards/paino-keyboard/","text":"","title":"Piano Keyboards"},{"location":"getting-started/chords/","text":"Chords We've already covered how we can play multiple notes at the same time thanks to the parallel operator . However, there is a handy shortcut to produce chords, that also has the benefit of identifying semantically that those notes are indeed part of the same chord. 1 2 3 [ CFG ] / 2 [ CFG ] # Is roughly equivalent to ( C/2 | F/2 | G/2 ) ( C | F | G ) As can be seen, wrapping the notes in square brackets [ ] avoids the need to manually put all notes in parallel. It also avoids the need to set the length of each note manually. However, instead of typing each individual note of the chord, it is also possible to create a chord from a root note and specifying the type of chord needed. 1 [ Cm ] / 2 [ CM ] Chord Abbreviations As of now, the supported chord abbreviations are as follows: Group Abbreviations Triads M / m / aug / dim / + Sevenths m7 / M7 / dom7 / 7 / m7b5 / dim7 / mM7 Perfect Fifth 5","title":"Chords"},{"location":"getting-started/chords/#chords","text":"We've already covered how we can play multiple notes at the same time thanks to the parallel operator . However, there is a handy shortcut to produce chords, that also has the benefit of identifying semantically that those notes are indeed part of the same chord. 1 2 3 [ CFG ] / 2 [ CFG ] # Is roughly equivalent to ( C/2 | F/2 | G/2 ) ( C | F | G ) As can be seen, wrapping the notes in square brackets [ ] avoids the need to manually put all notes in parallel. It also avoids the need to set the length of each note manually. However, instead of typing each individual note of the chord, it is also possible to create a chord from a root note and specifying the type of chord needed. 1 [ Cm ] / 2 [ CM ]","title":"Chords"},{"location":"getting-started/chords/#chord-abbreviations","text":"As of now, the supported chord abbreviations are as follows: Group Abbreviations Triads M / m / aug / dim / + Sevenths m7 / M7 / dom7 / 7 / m7b5 / dim7 / mM7 Perfect Fifth 5","title":"Chord Abbreviations"},{"location":"getting-started/combinators/","text":"Combinators We've already covered how to describe notes and rests, some of the basic building blocks of our language. It is useful to discuss how these blocks can be combined with each other, from single notes and rests to something more interesting. Sequential The most basic form of music composition is sequential: each value is played after the last one ends. To do this in our language, just write each value one after the other separated by whitespace. C F G Grouping Another possible combinator is grouping values with parenthesis ( ) . This is not very interesting in and of itself (simply grouping together a sequence of notes is exatcly the same as just playing the notes sequentially), grouping can be extremely powerful when employed alongside the other combinators. ( C F ) G Parallel Sequential notes can be played simply by writing them in a sequence (one after the other). Parallel notes, however, can be described by using a pipe separator | between them. C | G Since playing each note in parallel can become cumbersome, we can use groups to make the task more straighforward. ( C E | G B ) This example is equivalent to (C | G) (E | B) , which means the notes C and G play in parallel, and after, the notes E and B also play in parallel. Since the complexity of the expressions that compose the parallel operator can vary, and they are not required to have the same length (this is, to last the same time), the length of the entire parallel expression is always determined by the longer component. Repeat It is possible to repeat any musical element by using the multiply operator * . For instance, playing the not A five times could be acomplished like so A*5 . However, more interesting than repeating a single note, is repeating groups of notes. ( C F G ) * 2","title":"Combinators"},{"location":"getting-started/combinators/#combinators","text":"We've already covered how to describe notes and rests, some of the basic building blocks of our language. It is useful to discuss how these blocks can be combined with each other, from single notes and rests to something more interesting.","title":"Combinators"},{"location":"getting-started/combinators/#sequential","text":"The most basic form of music composition is sequential: each value is played after the last one ends. To do this in our language, just write each value one after the other separated by whitespace. C F G","title":"Sequential"},{"location":"getting-started/combinators/#grouping","text":"Another possible combinator is grouping values with parenthesis ( ) . This is not very interesting in and of itself (simply grouping together a sequence of notes is exatcly the same as just playing the notes sequentially), grouping can be extremely powerful when employed alongside the other combinators. ( C F ) G","title":"Grouping"},{"location":"getting-started/combinators/#parallel","text":"Sequential notes can be played simply by writing them in a sequence (one after the other). Parallel notes, however, can be described by using a pipe separator | between them. C | G Since playing each note in parallel can become cumbersome, we can use groups to make the task more straighforward. ( C E | G B ) This example is equivalent to (C | G) (E | B) , which means the notes C and G play in parallel, and after, the notes E and B also play in parallel. Since the complexity of the expressions that compose the parallel operator can vary, and they are not required to have the same length (this is, to last the same time), the length of the entire parallel expression is always determined by the longer component.","title":"Parallel"},{"location":"getting-started/combinators/#repeat","text":"It is possible to repeat any musical element by using the multiply operator * . For instance, playing the not A five times could be acomplished like so A*5 . However, more interesting than repeating a single note, is repeating groups of notes. ( C F G ) * 2","title":"Repeat"},{"location":"getting-started/grids/","text":"Grids Grids provide a way for the user to define rules for how to align musical events (also referred to as quantization ) in order to remove imprecisions resulting from the process of performing the music live. Grids can change just the duration of events, or only their start time. They can also affect each event individually, of treat certain groups of events as one atomic unit. The most important parameter of a grid is it's cell duration (or length). Any events that don't fall on the edges of a grid cell are pushed to the closest one. 1 2 3 4 5 6 7 8 $grid = keyboard\\Grid ( 1 / 2 ); # We can then instruct a keyboard to use this grid @keyboard toggle extend { z : C ; x: D ; c : E ; } :: with_grid ( $grid ) ; In the example below, Event A would be moved to the position 0 , while Event B would be moved to the position 1/2 . Direction It is also possible to condition a grid to only align events left (backards in time) or right (forwards in time) relative to the event's original timestamp. 1 $grid = keyboard\\Grid ( 1 / 2 , direction = 'left' ); In this case, both events would be moved to the position 0 . Aditionally, there are also two parameters that control when the alignment should occur, and when the event should be left untouched. Range How close (in time units) the event has to be from a cell edge to still be realigned. Forgiveness How close (in time units) the event has to be from a cell edge to not be realigned. Both of those parameters can be set once equally, or customized for each side ( left and right ). Range Range describes how close to a cell edge an event has to be to still be realigned. This means that events too far away are ignored. When no custom range is provided, the grid covers the entire cell duration. We can provide a equal range for both directions, or specify different values for the left and right directions. 1 $grid = keyboard\\Grid ( 1 / 2 , range_left = 600 , range_right = 200 ); As we can see, a grid cell does not have to be completely covered, neither do both ranges have to be the same. In this case, the Event A will be left untouched, while Event B will be moved to the position 1/2 . Forgiveness We've seen how ranges can leave events far away from the edges left untouched. But what if we want to ignore the ones close to the edges? Forgiveness is the opposite of range . 1 $grid = keyboard\\Grid ( 1 / 2 , forgiveness_left = 300 ); Here we see that every cell edge has a gap to their left with the duration of 300ms . This leaves Event B untouched, while Event A is still pulled to the left. Composition We've covered above how we can customize to our needs how each grid affects each event. But using only one grid is still limiting. That's why we can compose multiple grids, each with their own ranges and forgiveness, in a sequential manner, to 1 2 3 4 $grid = $keyboard\\Grid :: compose ( keyboard\\Grid ( 1 / 2 , direction = 'left' , forgiveness_left = 500 ), #g1 keyboard\\Grid ( 1 / 2 , direction = 'right' ) #g2 ); In this example, we see how the first grid aligns Event A to the left, but ignores EventB because of the forgiveness parameter. Right after, the second grid then ignores Event A because it is already aligned, and aligns Event B to the right.","title":"Grids"},{"location":"getting-started/grids/#grids","text":"Grids provide a way for the user to define rules for how to align musical events (also referred to as quantization ) in order to remove imprecisions resulting from the process of performing the music live. Grids can change just the duration of events, or only their start time. They can also affect each event individually, of treat certain groups of events as one atomic unit. The most important parameter of a grid is it's cell duration (or length). Any events that don't fall on the edges of a grid cell are pushed to the closest one. 1 2 3 4 5 6 7 8 $grid = keyboard\\Grid ( 1 / 2 ); # We can then instruct a keyboard to use this grid @keyboard toggle extend { z : C ; x: D ; c : E ; } :: with_grid ( $grid ) ; In the example below, Event A would be moved to the position 0 , while Event B would be moved to the position 1/2 .","title":"Grids"},{"location":"getting-started/grids/#direction","text":"It is also possible to condition a grid to only align events left (backards in time) or right (forwards in time) relative to the event's original timestamp. 1 $grid = keyboard\\Grid ( 1 / 2 , direction = 'left' ); In this case, both events would be moved to the position 0 . Aditionally, there are also two parameters that control when the alignment should occur, and when the event should be left untouched. Range How close (in time units) the event has to be from a cell edge to still be realigned. Forgiveness How close (in time units) the event has to be from a cell edge to not be realigned. Both of those parameters can be set once equally, or customized for each side ( left and right ).","title":"Direction"},{"location":"getting-started/grids/#range","text":"Range describes how close to a cell edge an event has to be to still be realigned. This means that events too far away are ignored. When no custom range is provided, the grid covers the entire cell duration. We can provide a equal range for both directions, or specify different values for the left and right directions. 1 $grid = keyboard\\Grid ( 1 / 2 , range_left = 600 , range_right = 200 ); As we can see, a grid cell does not have to be completely covered, neither do both ranges have to be the same. In this case, the Event A will be left untouched, while Event B will be moved to the position 1/2 .","title":"Range"},{"location":"getting-started/grids/#forgiveness","text":"We've seen how ranges can leave events far away from the edges left untouched. But what if we want to ignore the ones close to the edges? Forgiveness is the opposite of range . 1 $grid = keyboard\\Grid ( 1 / 2 , forgiveness_left = 300 ); Here we see that every cell edge has a gap to their left with the duration of 300ms . This leaves Event B untouched, while Event A is still pulled to the left.","title":"Forgiveness"},{"location":"getting-started/grids/#composition","text":"We've covered above how we can customize to our needs how each grid affects each event. But using only one grid is still limiting. That's why we can compose multiple grids, each with their own ranges and forgiveness, in a sequential manner, to 1 2 3 4 $grid = $keyboard\\Grid :: compose ( keyboard\\Grid ( 1 / 2 , direction = 'left' , forgiveness_left = 500 ), #g1 keyboard\\Grid ( 1 / 2 , direction = 'right' ) #g2 ); In this example, we see how the first grid aligns Event A to the left, but ignores EventB because of the forgiveness parameter. Right after, the second grid then ignores Event A because it is already aligned, and aligns Event B to the right.","title":"Composition"},{"location":"getting-started/keyboards/","text":"Keyboards One of the strenghts of the musikla (and the reason there's even a k in the name) is its ability to build custom keyboards. These keyboards can be thought of as dictionaries that map an event (like a a key press) to an action (which can be a function, a code block, an expression or music to play). 1 2 3 4 5 6 7 $repeat = 1 ; @keyboard { c : c * $repeat ; c t rl + up: { $repeat += 1 }; c t rl + d own: { $repeat -= 1 }; }; In this example we can observe how to play a note when a key is triggered. We cal also see how it is possible to change the state of the program with the keyboard and code blocks, which can be associated with keys as well. Event Types The most basic type of events a keyboard can react to are the actual key presses of the computer's keyboard. However, the keyboard is built with extensibility in mind, and features multiple events on it's own. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 $int = 0 ; @keyboard { # Keyboard c key c : c ; # Mo re c omp le x k e y s t r ok es c t rl + c : ^c ; # Ra w K e y b o ard Sca n C o de [ 16 ] : d ; # MI D I Not e E v e nt [ c' ] : e ; # L i s t e n for mou se scr o ll e v e nt s [ keyboard\\MouseScroll () ] ( $dy ) : { $int += $dy ; e + $int }; }; But the syntax above is just syntatic sugar. In reality, the example above is the same as the one below, just with less verbosity. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 $int = 0 ; @keyboard { # Keyboard c key [ keyboard\\KeyStroke ( 'c' ) ] : c ; # Mo re c omp le x k e y s t r ok es [ keyboard\\KeyStroke ( 'c', ctrl = true ) ] : ^c ; # Ra w K e y b o ard Sca n C o de [ keyboard\\KeyStroke ( 16 ) ] : d ; # MI D I Not e E v e nt [ keyboard\\PianoKey ( c' ) ] : e ; # L i s t e n for mou se scr o ll e v e nt s [ keyboard\\MouseScroll () ] ( $dy ) : { $int += $dy ; e + $int }; }; The currently available types of events provided out-of-the-box by the language are the following: Type Parameters Description keyboard\\KeyStroke N/A Is triggered by a bey press/release. keyboard\\PianoKey $vel Is triggered by a note on/off midi event. keyboard\\MouseClick $x , $y , $button , $pressed Is triggered when a mouse button is clicked. keyboard\\MouseMove $x , $y Is triggered when the mouse moves. keyboard\\MouseScroll $x , $y , $dx , $dy Is triggered when the mouse scrolls. Event Flags It is possible to customize how each event behaves with some flags. These flags can be placed at the top near the @keyboard keyword, to act as global flags that apply to all keys in that keyboard, or they can also be placed on each individual key. 1 2 3 4 @keyboard toggle { a repeat : C ; s : G/2 ; } ; Currently there are four flags available to customize the behavior of the keyboard. Without any flags, the default behavior of a key is to start playing it's music in full when pressed. Flag Description repeat Repeats the music played by this key infinitely, until the key is stopped. hold Starts playing on key press, but stops when the key is released. toggle Starts playing when the key is pressed once, and stops when it is pressed again. extend Ignores the length of the note(s), and instead play it while the key is active. Control Structures To avoid having to type every keyboard key manually, when a pattern or repetition can be devised, control structures such as for and while loops or if and else conditionals can be employed. 1 2 3 4 5 6 7 8 9 10 11 $array = @ [ 'z' , 'x' , 'c' , 'v' ]; @keyboard { for ($i in range( len( $array ) ) ) { { $key = C : :first_note () + $scale :: white_keys :: interval_at ( $i ) ; } ; [ $array :: [ $i ] ] : $key ; } } The body of these structures still needs to be keyboard declaration shortcuts, not random statements. However, if one needs custom code inside the loops, regular code blocks can be inserted wrapped around by braces { and } .","title":"Keyboards"},{"location":"getting-started/keyboards/#keyboards","text":"One of the strenghts of the musikla (and the reason there's even a k in the name) is its ability to build custom keyboards. These keyboards can be thought of as dictionaries that map an event (like a a key press) to an action (which can be a function, a code block, an expression or music to play). 1 2 3 4 5 6 7 $repeat = 1 ; @keyboard { c : c * $repeat ; c t rl + up: { $repeat += 1 }; c t rl + d own: { $repeat -= 1 }; }; In this example we can observe how to play a note when a key is triggered. We cal also see how it is possible to change the state of the program with the keyboard and code blocks, which can be associated with keys as well.","title":"Keyboards"},{"location":"getting-started/keyboards/#event-types","text":"The most basic type of events a keyboard can react to are the actual key presses of the computer's keyboard. However, the keyboard is built with extensibility in mind, and features multiple events on it's own. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 $int = 0 ; @keyboard { # Keyboard c key c : c ; # Mo re c omp le x k e y s t r ok es c t rl + c : ^c ; # Ra w K e y b o ard Sca n C o de [ 16 ] : d ; # MI D I Not e E v e nt [ c' ] : e ; # L i s t e n for mou se scr o ll e v e nt s [ keyboard\\MouseScroll () ] ( $dy ) : { $int += $dy ; e + $int }; }; But the syntax above is just syntatic sugar. In reality, the example above is the same as the one below, just with less verbosity. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 $int = 0 ; @keyboard { # Keyboard c key [ keyboard\\KeyStroke ( 'c' ) ] : c ; # Mo re c omp le x k e y s t r ok es [ keyboard\\KeyStroke ( 'c', ctrl = true ) ] : ^c ; # Ra w K e y b o ard Sca n C o de [ keyboard\\KeyStroke ( 16 ) ] : d ; # MI D I Not e E v e nt [ keyboard\\PianoKey ( c' ) ] : e ; # L i s t e n for mou se scr o ll e v e nt s [ keyboard\\MouseScroll () ] ( $dy ) : { $int += $dy ; e + $int }; }; The currently available types of events provided out-of-the-box by the language are the following: Type Parameters Description keyboard\\KeyStroke N/A Is triggered by a bey press/release. keyboard\\PianoKey $vel Is triggered by a note on/off midi event. keyboard\\MouseClick $x , $y , $button , $pressed Is triggered when a mouse button is clicked. keyboard\\MouseMove $x , $y Is triggered when the mouse moves. keyboard\\MouseScroll $x , $y , $dx , $dy Is triggered when the mouse scrolls.","title":"Event Types"},{"location":"getting-started/keyboards/#event-flags","text":"It is possible to customize how each event behaves with some flags. These flags can be placed at the top near the @keyboard keyword, to act as global flags that apply to all keys in that keyboard, or they can also be placed on each individual key. 1 2 3 4 @keyboard toggle { a repeat : C ; s : G/2 ; } ; Currently there are four flags available to customize the behavior of the keyboard. Without any flags, the default behavior of a key is to start playing it's music in full when pressed. Flag Description repeat Repeats the music played by this key infinitely, until the key is stopped. hold Starts playing on key press, but stops when the key is released. toggle Starts playing when the key is pressed once, and stops when it is pressed again. extend Ignores the length of the note(s), and instead play it while the key is active.","title":"Event Flags"},{"location":"getting-started/keyboards/#control-structures","text":"To avoid having to type every keyboard key manually, when a pattern or repetition can be devised, control structures such as for and while loops or if and else conditionals can be employed. 1 2 3 4 5 6 7 8 9 10 11 $array = @ [ 'z' , 'x' , 'c' , 'v' ]; @keyboard { for ($i in range( len( $array ) ) ) { { $key = C : :first_note () + $scale :: white_keys :: interval_at ( $i ) ; } ; [ $array :: [ $i ] ] : $key ; } } The body of these structures still needs to be keyboard declaration shortcuts, not random statements. However, if one needs custom code inside the loops, regular code blocks can be inserted wrapped around by braces { and } .","title":"Control Structures"},{"location":"getting-started/notes-and-rests/","text":"Notes & Rests In Musikla, notes are first-class primitives, just like numbers or strings or booleans are in most programming languages. This means we can put notes anywhere a value is expected, without the need for any special syntax. Also of note, any notes that are not stored in a variable or passed to a function are played automatically. Calling the play() function is optional. Notes Notes are represented by the letters C , D , E , F , G , A and B . Middle C , also known as C4 , is represented by C . Octaves To lower the octave, we can add commas , after the note. To up one octave, we can first use the lower case letter c , and to up further we can add apostrophes ' after the letter. Here is a full scale of C's: C,,,, C,,, C,, C, C c c' c'' c''' c'''' c''''' The lowest possible note is C,,,, and the highest is g''''' . Accidentals It is possible to describe accidentals by prefixing the note with either ^^ , ^ , _ or __ . Thus, it is possible to represent all the keys in a piano like so: C ^C D ^D E ^F F ^G G ^A A B Note In practice ^^C == D and __D == C ; Note Lengths Not all notes have the same length (or duration). The default length of all notes is 1 beat. This can be changed by appending the note with its length. C1/2 (or the equivalent C/2 ) describes a half note (or a minim ) C1 (or the equivalent C ) describes a whole note (or a semibreve ) C2 describes a double whole note (or a breve ) The actual duration of the note (in seconds) is determined by the beats per minute ( BPM ) and the time signature of the current voice . Rests Rests allow us to describe pauses: moments of silence between notes. They are described by the letter r . The length of a rest can be described in the same way as the length of a note . c2 r3/4 c","title":"Notes & Rests"},{"location":"getting-started/notes-and-rests/#notes-rests","text":"In Musikla, notes are first-class primitives, just like numbers or strings or booleans are in most programming languages. This means we can put notes anywhere a value is expected, without the need for any special syntax. Also of note, any notes that are not stored in a variable or passed to a function are played automatically. Calling the play() function is optional.","title":"Notes &amp; Rests"},{"location":"getting-started/notes-and-rests/#notes","text":"Notes are represented by the letters C , D , E , F , G , A and B . Middle C , also known as C4 , is represented by C .","title":"Notes"},{"location":"getting-started/notes-and-rests/#octaves","text":"To lower the octave, we can add commas , after the note. To up one octave, we can first use the lower case letter c , and to up further we can add apostrophes ' after the letter. Here is a full scale of C's: C,,,, C,,, C,, C, C c c' c'' c''' c'''' c''''' The lowest possible note is C,,,, and the highest is g''''' .","title":"Octaves"},{"location":"getting-started/notes-and-rests/#accidentals","text":"It is possible to describe accidentals by prefixing the note with either ^^ , ^ , _ or __ . Thus, it is possible to represent all the keys in a piano like so: C ^C D ^D E ^F F ^G G ^A A B Note In practice ^^C == D and __D == C ;","title":"Accidentals"},{"location":"getting-started/notes-and-rests/#note-lengths","text":"Not all notes have the same length (or duration). The default length of all notes is 1 beat. This can be changed by appending the note with its length. C1/2 (or the equivalent C/2 ) describes a half note (or a minim ) C1 (or the equivalent C ) describes a whole note (or a semibreve ) C2 describes a double whole note (or a breve ) The actual duration of the note (in seconds) is determined by the beats per minute ( BPM ) and the time signature of the current voice .","title":"Note Lengths"},{"location":"getting-started/notes-and-rests/#rests","text":"Rests allow us to describe pauses: moments of silence between notes. They are described by the letter r . The length of a rest can be described in the same way as the length of a note . c2 r3/4 c","title":"Rests"},{"location":"getting-started/programming/","text":"Programming A musikla script is just a sequence of statements ( and expressions ). Each statement must be followed by a ; , even if it ends in brackes { and } like an if or while . Variables Variables can stored and accessed by prefixing their name with a dollar sign `$. 1 2 3 $var_name = true ; print ( $var_name == null or $var_name == false ); Function Declarations Functions are declared with the fun keyword, followed by an optional function name. Function declarations are expressions that return a reference to the newly created function. This means that they can be saved in variables, passed as parameters to other functions, or otherwise used anywhere an expression could generally be used. 1 2 3 fun hello_world ( $name = 'User' ) { return 'Hello ' + $name; }; Function bodies can be multiline (like in the example above, surrounded by brackets { } ) or single line indicated by an arrow => 1 fun hello_world ( $name = 'User' ) => 'Hello ' + $name; Reference Arguments Function arguments can be declared as ref , meaning that any changes done to them will be reflected on the variable outside the function. Reference 1 2 3 4 5 6 7 8 9 fun increment ( ref $var ) { $var += 1; }; $a = 0; inc( $a ); print( $a ); # prints 1 If/Else Right now else if 's are not supported. The else block is optional, of course. 1 2 3 4 5 if ( $condition ) { print ( 1 ); } else { print ( 2 ); }; While 1 2 3 while ( $condition ) { print ( 1 ); }; For 1 2 3 for ( $item in $collection ) { print ( $item ); }; Arrays Arrays are a very common construct in programming languages, and they have proven very useful here as well. Array literals can be constructed with the syntax @[] 1 2 3 4 5 6 7 8 9 $array = @ [ 1 , 2 , 3 , 4 ]; # Iterate over the array for ( $i in $array ) { print ( $i ); }; # Print the first and last element of the array print ( $array :: [ 0 ], $array :: [ - 1 ] ); Dictionaries Similar to arrays, dictionary literals can be constructed with the syntax @{} 1 $dict = @ { foo = 1 , bar = true , get = 1 }; Dictionaries have four methods: has() , get() , set() and delete() . For convenience, their values can also be accessed using the regular property accessor syntax. 1 2 3 4 5 6 7 8 9 10 11 # We check if the key exists, and access it directly if ( $dict :: has ( 'foo' ) ) { print ( $dict :: foo ); }; # With the `get` method we can provide a default value print ( $dict :: get ( 'foo' , default = null ) ); $dict :: set ( 'bar' , false ); $dict :: delete ( 'foo' ); Embedding Python It is possible to embed python code inside the language directly through the use of two directives: @py for single python expressions and @python for statement blocks. The first directive can only contain python expressions, but can be used anywhere in the code. For instance, if we wanted to be able to use python list comprehensions on an array, we could simply do: 1 2 3 $arr = @ [ 1 , 2 , 3 ]; $arr = @py { [ i * 2 for i in arr ] }; Note How variables in musikla are prefixed by a dollar sign $ but in python are referenced simply by their name The second directive @python currently can only be used at the end of the file, since it treats everything after it as python code. It's execution is hoisted though (runs before anything else) which gives the user the possibility of defining functions or classes in python and using them in their code. 1 2 3 4 5 6 7 8 $arr = @ [ 1 , 2 , 3 ]; do_something ( $arr ); @python @ export () def do_something ( arr ) : print ( arr )","title":"Programming"},{"location":"getting-started/programming/#programming","text":"A musikla script is just a sequence of statements ( and expressions ). Each statement must be followed by a ; , even if it ends in brackes { and } like an if or while .","title":"Programming"},{"location":"getting-started/programming/#variables","text":"Variables can stored and accessed by prefixing their name with a dollar sign `$. 1 2 3 $var_name = true ; print ( $var_name == null or $var_name == false );","title":"Variables"},{"location":"getting-started/programming/#function-declarations","text":"Functions are declared with the fun keyword, followed by an optional function name. Function declarations are expressions that return a reference to the newly created function. This means that they can be saved in variables, passed as parameters to other functions, or otherwise used anywhere an expression could generally be used. 1 2 3 fun hello_world ( $name = 'User' ) { return 'Hello ' + $name; }; Function bodies can be multiline (like in the example above, surrounded by brackets { } ) or single line indicated by an arrow => 1 fun hello_world ( $name = 'User' ) => 'Hello ' + $name;","title":"Function Declarations"},{"location":"getting-started/programming/#reference-arguments","text":"Function arguments can be declared as ref , meaning that any changes done to them will be reflected on the variable outside the function. Reference 1 2 3 4 5 6 7 8 9 fun increment ( ref $var ) { $var += 1; }; $a = 0; inc( $a ); print( $a ); # prints 1","title":"Reference Arguments"},{"location":"getting-started/programming/#ifelse","text":"Right now else if 's are not supported. The else block is optional, of course. 1 2 3 4 5 if ( $condition ) { print ( 1 ); } else { print ( 2 ); };","title":"If/Else"},{"location":"getting-started/programming/#while","text":"1 2 3 while ( $condition ) { print ( 1 ); };","title":"While"},{"location":"getting-started/programming/#for","text":"1 2 3 for ( $item in $collection ) { print ( $item ); };","title":"For"},{"location":"getting-started/programming/#arrays","text":"Arrays are a very common construct in programming languages, and they have proven very useful here as well. Array literals can be constructed with the syntax @[] 1 2 3 4 5 6 7 8 9 $array = @ [ 1 , 2 , 3 , 4 ]; # Iterate over the array for ( $i in $array ) { print ( $i ); }; # Print the first and last element of the array print ( $array :: [ 0 ], $array :: [ - 1 ] );","title":"Arrays"},{"location":"getting-started/programming/#dictionaries","text":"Similar to arrays, dictionary literals can be constructed with the syntax @{} 1 $dict = @ { foo = 1 , bar = true , get = 1 }; Dictionaries have four methods: has() , get() , set() and delete() . For convenience, their values can also be accessed using the regular property accessor syntax. 1 2 3 4 5 6 7 8 9 10 11 # We check if the key exists, and access it directly if ( $dict :: has ( 'foo' ) ) { print ( $dict :: foo ); }; # With the `get` method we can provide a default value print ( $dict :: get ( 'foo' , default = null ) ); $dict :: set ( 'bar' , false ); $dict :: delete ( 'foo' );","title":"Dictionaries"},{"location":"getting-started/programming/#embedding-python","text":"It is possible to embed python code inside the language directly through the use of two directives: @py for single python expressions and @python for statement blocks. The first directive can only contain python expressions, but can be used anywhere in the code. For instance, if we wanted to be able to use python list comprehensions on an array, we could simply do: 1 2 3 $arr = @ [ 1 , 2 , 3 ]; $arr = @py { [ i * 2 for i in arr ] }; Note How variables in musikla are prefixed by a dollar sign $ but in python are referenced simply by their name The second directive @python currently can only be used at the end of the file, since it treats everything after it as python code. It's execution is hoisted though (runs before anything else) which gives the user the possibility of defining functions or classes in python and using them in their code. 1 2 3 4 5 6 7 8 $arr = @ [ 1 , 2 , 3 ]; do_something ( $arr ); @python @ export () def do_something ( arr ) : print ( arr )","title":"Embedding Python"},{"location":"getting-started/sound-files/","text":"Sound Files We've seen how to play notes and chords from instruments, but sometimes it can be interesting to mix things up a bit and play sound files directly. Sound files can be played just like notes, and to do so, they simply have to be loaded first. 1 A B sample ( \"cihat.wav\" ); To avoid loading the sample every time, we can load it once and save it in a variable . 1 2 3 $cihat = sample ( \"cihat.wav\" ); A B $cihat ; The sound files can be in virtually any common format. If they are already optimized, they are loaded straight away. If not, they are converted in runtime in memory using FFMPEG in the background. NOTE Optimizing files in the background requires FFMPEG to be installed and available in the $PATH . Optimal Format Sound files in this format do not require any kind of preprocessing and can be loaded directly into memory, minimizing the performance overhead. When possible, use of convert files to this format. Setting Value Format WAVE Sample Rate 41.100hz Channels 1 ( Mono ) Bit depth 16bit Compression None Optimizing When the file format is not optimal, optimizing it beforehand can make the whole program more performant and reduce load times. To simplify the experience, and to avoid forcing the user to figure out what tool to use and what configurations to apply to convert the files, the language comes equipped with two utility functions that simplify this process. The user simply has to provide the file or folder paths containing the files he wishes to optimize, and indicate where the optimized versions should be saved. 1 2 3 4 5 6 # Converts a single file and stores it in the given path optimize_sample ( \"cihat.mp3\" , \"cihat.mp3\" ); # Converts every file inside the `samples/` folder into an optimized version #and stores them, with the same name inside the `samples-optimized/` folder. optimize_samples_folder ( \"samples/\" , \"samples-optimized/\" );","title":"Sound Files"},{"location":"getting-started/sound-files/#sound-files","text":"We've seen how to play notes and chords from instruments, but sometimes it can be interesting to mix things up a bit and play sound files directly. Sound files can be played just like notes, and to do so, they simply have to be loaded first. 1 A B sample ( \"cihat.wav\" ); To avoid loading the sample every time, we can load it once and save it in a variable . 1 2 3 $cihat = sample ( \"cihat.wav\" ); A B $cihat ; The sound files can be in virtually any common format. If they are already optimized, they are loaded straight away. If not, they are converted in runtime in memory using FFMPEG in the background. NOTE Optimizing files in the background requires FFMPEG to be installed and available in the $PATH .","title":"Sound Files"},{"location":"getting-started/sound-files/#optimal-format","text":"Sound files in this format do not require any kind of preprocessing and can be loaded directly into memory, minimizing the performance overhead. When possible, use of convert files to this format. Setting Value Format WAVE Sample Rate 41.100hz Channels 1 ( Mono ) Bit depth 16bit Compression None","title":"Optimal Format"},{"location":"getting-started/sound-files/#optimizing","text":"When the file format is not optimal, optimizing it beforehand can make the whole program more performant and reduce load times. To simplify the experience, and to avoid forcing the user to figure out what tool to use and what configurations to apply to convert the files, the language comes equipped with two utility functions that simplify this process. The user simply has to provide the file or folder paths containing the files he wishes to optimize, and indicate where the optimized versions should be saved. 1 2 3 4 5 6 # Converts a single file and stores it in the given path optimize_sample ( \"cihat.mp3\" , \"cihat.mp3\" ); # Converts every file inside the `samples/` folder into an optimized version #and stores them, with the same name inside the `samples-optimized/` folder. optimize_samples_folder ( \"samples/\" , \"samples-optimized/\" );","title":"Optimizing"},{"location":"getting-started/voices/","text":"Voices Voices allow a easy way of grouping notes and applying settings to all of them, such as the volume or instrument. By default, there is already one voice created and all notes played are played in that voice. Modifiers To change the settings of a voice, we make use of modifiers . Modifiers can be used anywhere notes can, and can be even used in the middle of notes. 1 S4/4 L1/4 V90 One interesting aspect is that by using groups , we can apply those modifiers to just a subset of notes. In the example below, we can see how to apply a change in volume v50 to only the notes that are inside the parenthesis. 1 C ( v50 F ) G Modifier Description S4/4 Changes the time signature to 4/4 . L2 L1/2 Sets the base note length . Each note's length is then calculated as a multiplier of this value. T120 Changes the tempo to 120 beats per minute ( BPM ). O1 Sets the base octave to 1 . C becomes C1 (instead of C4 ) and all other notes change as well I1 Change the voice's instrument to be the number 1 (usually follows the General MIDI Standard Named Voices Sometimes instead of changing the settings of the voice in everyplace we need them, we might want to create named voices. These voices can have default settings that are automatically applied when we change to that voice. Voice names are prepended by a colon : . The simplest voice declaration is to just define the name and instrument to be used. Using the name we just created, we can then change the voice anywhere. 1 2 3 :violin = I41 ; C F G ( :violin c f g ); However, voices can also be used to change more than just the instrument. We can pass them a sequence of modifiers as well, and they will be applied by default to the voice. Optionally, we can inherit those settings from other voices, to avoid typing them out one by one. 1 2 :piano = I1 S6/8 T140 L/8 V120 ; :violin = :piano ( I41 );","title":"Voices"},{"location":"getting-started/voices/#voices","text":"Voices allow a easy way of grouping notes and applying settings to all of them, such as the volume or instrument. By default, there is already one voice created and all notes played are played in that voice.","title":"Voices"},{"location":"getting-started/voices/#modifiers","text":"To change the settings of a voice, we make use of modifiers . Modifiers can be used anywhere notes can, and can be even used in the middle of notes. 1 S4/4 L1/4 V90 One interesting aspect is that by using groups , we can apply those modifiers to just a subset of notes. In the example below, we can see how to apply a change in volume v50 to only the notes that are inside the parenthesis. 1 C ( v50 F ) G Modifier Description S4/4 Changes the time signature to 4/4 . L2 L1/2 Sets the base note length . Each note's length is then calculated as a multiplier of this value. T120 Changes the tempo to 120 beats per minute ( BPM ). O1 Sets the base octave to 1 . C becomes C1 (instead of C4 ) and all other notes change as well I1 Change the voice's instrument to be the number 1 (usually follows the General MIDI Standard","title":"Modifiers"},{"location":"getting-started/voices/#named-voices","text":"Sometimes instead of changing the settings of the voice in everyplace we need them, we might want to create named voices. These voices can have default settings that are automatically applied when we change to that voice. Voice names are prepended by a colon : . The simplest voice declaration is to just define the name and instrument to be used. Using the name we just created, we can then change the voice anywhere. 1 2 3 :violin = I41 ; C F G ( :violin c f g ); However, voices can also be used to change more than just the instrument. We can pass them a sequence of modifiers as well, and they will be applied by default to the voice. Optionally, we can inherit those settings from other voices, to avoid typing them out one by one. 1 2 :piano = I1 S6/8 T140 L/8 V120 ; :violin = :piano ( I41 );","title":"Named Voices"}]}